# ***************Los operadores l贸gicos en Python (and, or, not) 
# se utilizan para "combinar expresiones booleanas" (que son True o False). 
# Permiten la tomar decisiones basadas en "varias condiciones al mismo tiempo".
print('Operadores Logicos: and, or, not')

***************Operador and (Y l贸gico):
Devuelve True s贸lo si ambas condiciones son verdaderas.
Si alguna es False, el resultado es False.

Ejemplo:
temperatura = 25
hace_sol = True
if temperatura > 20 and hace_sol:
    print("隆D铆a perfecto para un picnic!")
El mensaje se imprime s贸lo si la temperatura es mayor que 20 y est谩 soleado.



***************Operador or (O l贸gico):
Devuelve True si al menos una condici贸n es verdadera.
S贸lo devuelve False si todas las condiciones son falsas.

Ejemplo:
tiene_paraguas = False
if hace_sol or tiene_paraguas:
    print("隆Vamos a pasear!")
Aqu铆 se sale a pasear si hace sol o si se tiene paraguas.



***************Operador not (Negaci贸n l贸gica):
Invierte el valor booleano de una condici贸n.
Si la condici贸n es True, not la convierte en False, y viceversa.
#& 桂解桂解桂解桂 EJERCICIO 1: como puedo expresar que: si es NO hace_sol deberia quedarme en casa

if not hace_sol:
    print("Quiz谩s deber铆amos quedarnos en casa.")
Se imprime s贸lo si no est谩 soleado.


******************锔驴Por qu茅 son importantes?
Permiten combinar m煤ltiples condiciones en una sola expresi贸n.
Facilitan la toma de decisiones m谩s complejas y precisas en programas.
Son fundamentales en estructuras condicionales (if, while) para controlar el flujo del c贸digo.

******************Evaluaci贸n y cortocircuito
Python eval煤a los operadores l贸gicos usando evaluaci贸n en cortocircuito, es decir:
En and, si la primera condici贸n es False, no eval煤a la segunda porque el resultado ya ser谩 False.
En or, si la primera condici贸n es True, no eval煤a la segunda porque el resultado ya ser谩 True.












# ***************Los operadores de Comparaci贸n en Python 
permiten "comparar dos" valores o expresiones y siempre devuelven un 
resultado booleano (True o False). Usados para tomar decisiones en un programa, 
por ejemplo dentro de estructuras condicionales (if, while, etc.).
print('Operadores de Comparaci贸n: ==, !=, <, >, <=, >=')

*************锔驴C贸mo funcionan con tipo de dato num茅ricos?
Es intuitivo, comparan sus valores num茅ricos naturalmente.

Ejemplo:
print(4 == 4.0)  # True, porque 4 y 4.0 representan el mismo valor num茅rico
print(5 > 3)     # True


*************锔驴C贸mo funcionan con tipo de dato Booleanos?
Se tratan como 1 (True) y 0 (False).

Ejemplo:
print(True > False)  # True (1 > 0)


*************锔驴C贸mo funcionan con tipo de dato String?
Se comparan lexicogr谩ficamente seg煤n el orden Unicode de cada car谩cter.
Python compara cadena por cadena car谩cter a car谩cter, 
usando el valor num茅rico Unicode de cada car谩cter (obtenible con ord(caracter)).

La comparaci贸n se realiza en orden: se compara el primer car谩cter de ambas cadenas; 
si son iguales, se pasa al siguiente, y as铆 sucesivamente.
El resultado es True o False seg煤n la relaci贸n entre las cadenas.
Las letras may煤sculas y min煤sculas se diferencian porque tienen 
valores Unicode distintos ('A' < 'a').

Solo puedes usar los operadores (==, !=, <, >, <=, >=) entre dos cadenas.
 
Ejemplo:
print("abc" < "abd")  # True, porque 'c' es menor que 'd'  
print("A" < "a")      # True, porque may煤sculas tienen menor c贸digo Unicode que las min煤sculas  
print("hola" == "hola")  # True  
print("hola" != "mundo") # True 

No mezcles tipos diferentes, como str con int en comparaciones directas, porque no son compatibles, 
si lo intentas usando operadores de orden (<, >, etc.), Python lanzar谩 un TypeError. 
Sin embargo, == y != s铆 pueden comparar distintos tipos siempre, retornando casi siempre False 
(excepto casos especiales).
print("3" == 3)  # False  
print("3" < 3)   # TypeError 

庐锔くResumen clave
Los operadores de comparaci贸n devuelven True o False.
Debes comparar preferentemente valores del mismo tipo para evitar errores.
Para cadenas, la comparaci贸n es lexicogr谩fica, sensible a may煤sculas y min煤sculas.
En tipos num茅ricos, se comportan naturalmente seg煤n valor.
== y != pueden comparar distintos tipos pero otros operadores NO.
print('"M" == 77', "M" == 77)           #*"M" == 77 False
print('ord("M") == 77', ord("M") == 77) #*ord("M") == 77 True






# ***************Los operadores de Asignaci贸n en Python 
Sirven para asignar valores a variables y actualizar esos valores. 
El operador b谩sico es =, que asigna directamente un valor, pero existen operadores compuestos 
que combinan una operaci贸n con la asignaci贸n.

*****************Operador b谩sico de asignaci贸n
= asigna el valor de la derecha a la variable de la izquierda.
x = 7  # x recibe el valor 7


******************Operadores de asignaci贸n compuestos
Permiten realizar una operaci贸n con el valor actual de la variable y luego 
asignar el resultado a esa misma variable. Son equivalentes a escribir la operaci贸n completa 
con asignaci贸n, pero en forma abreviada.


庐锔Resumen
El operador = asigna un valor directamente.
くLos operadores compuestos (+=, -=, *=, etc.) modifican la variable bas谩ndose en su valor actual.
Son 煤tiles para escribir c贸digo m谩s limpio y eficiente.


x = 5
x += 5
x -= 2
x *= 10
x /= 2
x //= 4
x %= 4
print("x es = ", (x)) #* x es =  2.0
x **= 0               #* Resultado 1.0
print("Resultado", (x)) 


print('Ejercicios')
a = 7
b = 2

x = a
x += b      #* x = x + 2 = 9
print('x += b:', x)

x = a
x -= b      #* x = x - 2 = 5
print('x -= b:', x)

x = a
x *= b      #* x = x * 2 = 14
print('x *= b:', x)

x = a
x /= b      #* x = x / 2 = 3.5
print('x /= b:', x)

x = a
x %= b      #* x = x % 2 = 1
print('x %= b:', x)

x = a
x //= b     #* x = x // 2 = 3
print('x //= b:', x)

x = a
x **= b     #* x = x ** 2 = 49
print('x **= b:', x)



*********************く Mirar Propiedades de las potencias
0 elevado a la 0 est谩 indefinido matem谩ticamente.Pero en Python ^  = 1
Esto es porque, y para evitar ambig眉edades en c谩lculos y funciones, Python define 0**0 como 1
print('0**0 = ', 0**0) # *0**0 = 1
print('2**-3 = ', 2**-3) # *2**-3 = 0.125
print('(1/3)**-2 = ', (1/3)**-2) # *(1/3)**-2 =  9.000000000000002





# ***************La Precedencia Matem谩tica
La regla de precedencia matem谩tica en Python establece el orden en que se eval煤an 
los operadores dentro de una expresi贸n. Los operadores con mayor precedencia se ejecutan primero, 
y en caso de operadores con igual precedencia se siguen reglas de asociatividad 
(por ejemplo, potencias se asocian de derecha a izquierda, otros operadores de izquierda a derecha).

#*****************Reglas de la precedencia de operadores en Python:
1锔. Los par茅ntesis () tienen la precedencia m谩s alta y siempre sirven para forzar un orden espec铆fico 
en la evaluaci贸n de expresiones.

2锔. La potenciaci贸n ** es asociativa a la derecha, es decir, en una expresi贸n como 2 ** 3 ** 2 se eval煤a 
primero 3 ** 2 y luego el resultado eleva a 2:
2 ** (3 ** 2)  # equivalente a 2 ** 9 = 512

3锔. Los operadores de multiplicaci贸n *, divisi贸n /, divisi贸n entera // y m贸dulo % tienen la misma precedencia 
y se eval煤an de izquierda a derecha.

4锔. La suma + y resta - tienen precedencia menor que la multiplicaci贸n y divisi贸n, 
pero mayor que los operadores de desplazamiento y l贸gicos, y tambi茅n se eval煤an de izquierda a derecha.

5锔. Las comparaciones (<, <=, >, >=, ==, !=), junto con los operadores de identidad 
(is, is not) y pertenencia (in, not in), tienen una precedencia intermedia.

6锔. Los operadores l贸gicos not, and y or tienen la menor precedencia, y se eval煤an en ese orden: 
primero not, luego and, y finalmente or.


print('precedencia.py')

print((2+ 2) * 10**2 /5) # *80.0 ((), potencia, divisi贸n, suma)
print( 2+ 2  * 10**2 /5) # *42.0 (potencia, multiplicacion, divisi贸n, suma)

print(2 ** 3 ** 2)   # calcula 2 ** (3 ** 2) = 2 ** 9 = 512
print((2 ** 3) ** 2) # calcula (2 ** 3) ** 2 = 8 ** 2 = 64